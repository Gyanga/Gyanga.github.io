<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About me</title>
    <url>/2024/01/11/About%20me/</url>
    <content><![CDATA[<h2 id="😀对前端的认识"><a href="#😀对前端的认识" class="headerlink" title="😀对前端的认识"></a>😀对前端的认识</h2><ul>
<li><p>前端是用户接触到的部分，融合了设计、编码以及一些整体的理念，还涉及接口请求、数据处理和交互等方面，具有一定的挑战性</p>
</li>
<li><p>终端涵盖范围扩大，从PC端到移动端（H5、APP…）、智能设备等</p>
</li>
<li><p>前端社区活跃，技术在不断的更新</p>
<ul>
<li>技术文档：MDN，W3School，菜鸟教程</li>
<li>技术社区：Github，博客园，掘金，segmentfault（思否），极客时间，阮一峰的网络日志</li>
<li>前端常用技术：HTML-&gt;HTML5，CSS-&gt;CSS3，JavaScript（ES6+），框架（Vue、React、Angular），jQuery（JavaScript工具库），Node.js（一种JavaScript的运行环境，能够使得其脱离浏览器运行），npm（安装依赖）</li>
</ul>
</li>
<li><p>有发展前景</p>
</li>
<li><p>最主要的，个人感觉写前端更有成就感（想做一个技术girl）</p>
</li>
</ul>
<h2 id="😁-项目相关技术的了解"><a href="#😁-项目相关技术的了解" class="headerlink" title="😁 项目相关技术的了解"></a>😁 项目相关技术的了解</h2><ul>
<li><p>Vue</p>
<ul>
<li>构建用户界面的渐进式框架</li>
<li>语法简单、容易上手</li>
<li>组件化开发方便实现组件的复用</li>
</ul>
</li>
<li><p>Vuex</p>
<p>为Vue.js应用程序开发的状态管理模式，管理所有组件的状态（还可以实现组件间传值）</p>
</li>
<li><p>Element UI</p>
<p>一套基于Vue2.0的桌面组件库</p>
</li>
<li><p>Uni-app</p>
<p>一个使用Vue.js开发所有前端应用的框架，一套代码可以发布到多个平台</p>
</li>
<li><p>Node.js</p>
<p>可以让Javascript运行于服务器</p>
</li>
<li><p>webpack</p>
<p>前端资源模块化管理和打包工具</p>
</li>
</ul>
<h2 id="😅在项目过程中遇到的问题"><a href="#😅在项目过程中遇到的问题" class="headerlink" title="😅在项目过程中遇到的问题"></a>😅在项目过程中遇到的问题</h2><ol>
<li><p>页面自适应（响应式）</p>
<ul>
<li><p>uni-app:单位使用rpx</p>
</li>
<li><p>宽度单位不用绝对的，用百分比<code>%</code>或<code>auto</code></p>
</li>
<li><p>字体大小用相对字体大小<code>rem</code></p>
<p>字体大小是页面默认大小的100%，即16像素</p>
</li>
<li><p>使用流动布局float</p>
<p>整个区块的位置都是浮动的，不是固定不变的</p>
</li>
<li><p>选择加载CSS</p>
<p>CSS3引入的Media  Query模块可以自动探测屏幕宽度，然后加载相应的CSS文件</p>
</li>
<li><p>CSS的@media和@media screen，媒体查询&#x2F;匹配</p>
<p>@media和@media screen两者在手机设备上没有区别，但@media screen的css在打印设备里是无效的，@media在打印设备里是有效的</p>
</li>
<li><p>viewport</p>
<p>在移动设备上进行网页的重构和开发，让网页适配或响应各种不同分辨率的移动设备</p>
<p><a href="https://www.cnblogs.com/2050/p/3877280.html">https://www.cnblogs.com/2050/p/3877280.html</a></p>
</li>
</ul>
</li>
<li><p>性能优化</p>
<ul>
<li><p>减少<code>HTTP</code>请求</p>
<p>一个完整的HTTP请求需要经历DNS查找，TCP握手，浏览器发出HTTP请求，服务器接收请求、服务器处理请求并发回响应，浏览器接收响应等过程</p>
</li>
<li><p>将CSS放在文件头部，JavaScript文件放在底部</p>
</li>
<li><p>降低CSS选择器的复杂性</p>
</li>
<li><p>用<code>flex</code>模型替换浮动</p>
</li>
<li><p>使用字体图标<code>iconfont</code>代替图片图标</p>
</li>
<li><p>图片优化</p>
<ul>
<li>尽可能使用CSS效果代替图片</li>
<li>图片懒加载</li>
<li>对选用图片的格式类型进行选择<ul>
<li>jpg：支持颜色比较丰富</li>
<li>png：支持复杂透明度</li>
<li>webp：谷歌新推出的专门用来表示图片的一种格式，具备其他图片格式的所有优点（兼容性不好）</li>
<li>base64：将图片使用base64编码，可以将图片转换为字符，一般用来显示需要和页面一起加载的图片</li>
</ul>
</li>
</ul>
</li>
<li><p>JavaScript性能优化</p>
<ul>
<li><p>作用域意识</p>
<ul>
<li>使用<code>let</code>、<code>const</code>变量替代全局变量<code>var</code></li>
<li>避免使用<code>with</code>语句（with语句会创建自己的作用域，会加长其中代码的作用域链）</li>
</ul>
</li>
<li><p>选择性能更佳的算法或解决问题的方法</p>
<ul>
<li>避免不必要的属性查找</li>
<li>尽可能使用原生方法(Math对象上执行复杂数学运算的方法)</li>
<li>将复杂的<code>if-else</code>语句转换成<code>switch</code>语句</li>
<li>有选择性的将某些数学操作替换成位操作以提升复杂计算的效率（求模、逻辑AND与和逻辑OR或都很适合替代成位操作）</li>
</ul>
</li>
<li><p>语句最少化</p>
<ul>
<li>可以通过一条语句声明多个变量</li>
<li>尽量把迭代值插入到上一条使用它的语句中</li>
<li>使用数组和对象字面量（创建的同时进行初始化）</li>
</ul>
</li>
<li><p>优化DOM交互</p>
<ul>
<li><p>实时更新最小化</p>
</li>
<li><p>使用<code>innerHTML</code>（适用于大量DOM更新）</p>
<p>在页面中创建新DOM节点的方式：</p>
<ul>
<li><p>DOM方法：createElement()和appendChild()</p>
</li>
<li><p>innerHTML</p>
<p>PS:使用innerHTML会暴露巨大的XSS攻击面</p>
</li>
</ul>
</li>
<li><p>使用事件委托，可以减少对页面响应的影响</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>善用缓存，不重复加载相同的资源</p>
</li>
<li><p>减少重绘重排</p>
</li>
</ul>
</li>
<li><p>使用vue时组件间传值</p>
<p>主要用的<code>props / $emit</code>实现父子间的传值</p>
<p><code>vuex</code>实现各组件间数据处理和传递</p>
</li>
<li><p>合并代码时产生冲突</p>
<p>代码规范和沟通真的好好好重要，遵循规范和提前沟通可以避免很多冲突</p>
</li>
</ol>
<p>Ps: 官方文档真的是第一手教材</p>
<h2 id="😆项目中的收获"><a href="#😆项目中的收获" class="headerlink" title="😆项目中的收获"></a>😆项目中的收获</h2><ul>
<li>能力方面<ul>
<li>学习到了很多新东西以及他人解决问题的方式<ul>
<li>uniapp、git、iconfont、fastmock、设计理念和设计流程、编码规范等等</li>
<li>遇到了不会的内容应该积极利用搜索引擎查询</li>
<li>遇到bug时可以通过一步一步检查验证找出问题所在</li>
</ul>
</li>
<li>学习能力和解决问题能力得到了提高</li>
<li>团结协作能力和团队意识得到了提高</li>
</ul>
</li>
<li>意识方面<ul>
<li>学习应该主要从官方文档开始</li>
<li>编码规范极其重要<ul>
<li>代码格式规范—-&gt;美观</li>
<li>注释详细—-&gt;便于后期维护</li>
</ul>
</li>
<li>不能过于依赖组件</li>
<li>实现一个功能应该深入了解其实现原理，这样才能便于提升自己能力</li>
<li>团队成员之间的沟通交流很重要</li>
<li>应该积极向他人学习</li>
<li>学无止境</li>
</ul>
</li>
</ul>
<h2 id="😏个人优势"><a href="#😏个人优势" class="headerlink" title="😏个人优势"></a>😏个人优势</h2><ul>
<li><p>有一定的团队合作经验</p>
<p>参与过团队项目，做项目过程中会定期进行交流讨论，编码过程遵循团队的规范，具有强烈的团队意识，会使用多种协作软件</p>
</li>
<li><p>擅于总结和写文档</p>
<p>在学习和实践过程中大大小小的学习文档写了不少</p>
</li>
<li><p>对技术这方面很感兴趣</p>
<p>愿意花时间去学习技术，自己写个东西出来会很有成就感</p>
</li>
<li><p>自制力较强，生活作息规律</p>
<p>基本每天大概7点左右起床出去自习晚上十点左右回寝室</p>
</li>
<li><p>有一定的独立思考能力，学习目标明确</p>
</li>
<li><p>学习态度端正并乐于学习</p>
<p>会通过看视频讲解、官方文档、他人博客等解决自己遇到的问题，遇到自己无法解决的问题会主动向会的人请教，直到问题得到解决，问题被解决后会获得强烈的满足感。</p>
</li>
</ul>
<h2 id="😅个人不足"><a href="#😅个人不足" class="headerlink" title="😅个人不足"></a>😅个人不足</h2><ul>
<li><p>掌握的知识缺乏深度</p>
<p>能明显的感觉到自己学的东西不够深入，想实现什么功能一般是直接网上搜，然后修改运用到自己项目，很多时候不会去深究其中的原理</p>
<p>PS：在技术实现方面逐渐培养自己打破砂锅问到底的意识</p>
</li>
<li><p>基础知识还不够牢固</p>
<p>没有进行系统性的学习，学习内容零零散散，需要用到什么才去学什么</p>
<p> PS：开始了系统全面的学习，构建自己的知识框架</p>
</li>
<li><p>算法能力有待提高</p>
<p>算法接触得比较少</p>
<p>PS：通过实例来了解学习各个常用算法，并做好相对应的笔记</p>
</li>
</ul>
<h2 id="😉兴趣爱好"><a href="#😉兴趣爱好" class="headerlink" title="😉兴趣爱好"></a>😉兴趣爱好</h2><ul>
<li><p>写博客文章</p>
<p>喜欢将自己新学到的知识通过博客记录下来，能更好的掌握，同时方便自己之后进行查询（避免遗忘）</p>
</li>
<li><p>打羽毛球</p>
<p>最喜欢的锻炼方式没有之一</p>
</li>
<li><p>摄影</p>
<p>喜欢记录美好的生活瞬间</p>
</li>
<li><p>追海贼王</p>
<p>“我们是伙伴啊！”</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>H5支付</title>
    <url>/2024/01/11/H5%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<h2 id="🎈概述"><a href="#🎈概述" class="headerlink" title="🎈概述"></a>🎈概述</h2><p>​        H5支付时商户在微信客户端外的移动端页面展示商品或服务，用户在前述页面确定使用微信支付时，商户发起本服务呼起微信客户端进行支付</p>
<p>​        主要用于触屏版的手机浏览器请求微信支付的场景，可以方便的从外部浏览器唤起微信支付</p>
<h2 id="🎈业务流程"><a href="#🎈业务流程" class="headerlink" title="🎈业务流程"></a>🎈业务流程</h2><h3 id="⚡商户"><a href="#⚡商户" class="headerlink" title="⚡商户"></a>⚡商户</h3><p>H5商城网站，经过ICP备案。</p>
<p>通过H5支付可以实现在非微信浏览器中使用微信支付的场景</p>
<h3 id="⚡用户"><a href="#⚡用户" class="headerlink" title="⚡用户"></a>⚡用户</h3><ol>
<li>用户从非微信浏览器的站点导航进入商户H5网页，选择需购买商品选择微信支付发起购买流程</li>
<li>进入微信客户端确认交易，输入密码</li>
<li>支付成功，用户收到支付凭证同时商户后台收到支付成功的通知</li>
</ol>
<h2 id="🎈接口流程"><a href="#🎈接口流程" class="headerlink" title="🎈接口流程"></a>🎈接口流程</h2><ol>
<li>用户下单使用微信进行支付</li>
<li>商家后台向微信支付发起下单请求（交易类型trade_type&#x3D;MWEB）</li>
</ol>
<blockquote>
<p>URL地址：<a href="https://api.mch.weixin.qq.com/pay/unifiedorder">https://api.mch.weixin.qq.com/pay/unifiedorder</a></p>
</blockquote>
<p><strong>请求参数</strong>(必填参数)</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>变量名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>公众号ID</td>
<td>appid</td>
<td>String(32)</td>
<td>微信分配的公众号ID</td>
</tr>
<tr>
<td>商户号</td>
<td>mch_id</td>
<td>String(32)</td>
<td>微信支付分配的商户号</td>
</tr>
<tr>
<td>随机字符串</td>
<td>nonce_str</td>
<td>String(32)</td>
<td>随机字符串，可通过<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=4_3">随机数生成算法</a>生成</td>
</tr>
<tr>
<td>签名</td>
<td>sign</td>
<td>String(32)</td>
<td>签名，可通过<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=4_3">签名生成算法</a>生成</td>
</tr>
<tr>
<td>商品描述</td>
<td>body</td>
<td>String(128)</td>
<td>商品简单描述，需按<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=4_2">规范</a>传递</td>
</tr>
<tr>
<td>商户订单号</td>
<td>out_trade_no</td>
<td>String(32)</td>
<td>商户系统内部的<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=4_2">订单号</a></td>
</tr>
<tr>
<td>总金额</td>
<td>total_fee</td>
<td>Int</td>
<td>订单总金额，单位为分</td>
</tr>
<tr>
<td>终端IP</td>
<td>spbill_create_ip</td>
<td>String(64)</td>
<td>用户端IP，<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_5">获取方式</a></td>
</tr>
<tr>
<td>通知地址</td>
<td>notify_url</td>
<td>String(256)</td>
<td>接收微信支付异步通知回调地址（可直接访问，不能携带参数）</td>
</tr>
<tr>
<td>交易类型</td>
<td>trade_type</td>
<td>Srting(16)</td>
<td>H5支付的交易类型为<code>MWEB</code></td>
</tr>
<tr>
<td>场景信息</td>
<td>scene_info</td>
<td>Striing(256)</td>
<td>用于上报支付的<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=9_20&index=1">场景信息</a>（IOS移动应用、安卓移动应用、WAP网站应用、门店信息）</td>
</tr>
</tbody></table>
<ol start="3">
<li>统一接口返回支付相关参数给商户后台（如支付跳转url）</li>
</ol>
<p><strong>返回结果</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>变量名</th>
<th>类型</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>返回状态码</td>
<td>return_code</td>
<td>String(16)</td>
<td>SUCCESS</td>
<td>通信标识（SUCCESS&#x2F;FAIL）</td>
</tr>
<tr>
<td>返回信息</td>
<td>return_msg</td>
<td>String(128)</td>
<td>OK</td>
<td>当返回状态码为FAIL时返回信息为错误原因</td>
</tr>
</tbody></table>
<p>return_code为SUCCESS时返回：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>变量名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>公共账号ID</td>
<td>appid</td>
<td>String(32)</td>
<td>调用接口提交的公众账号ID</td>
</tr>
<tr>
<td>商户号</td>
<td>mch_id</td>
<td>String(32)</td>
<td>调用接口提交的商户号</td>
</tr>
<tr>
<td>随机字符串</td>
<td>nonce_str</td>
<td>String(32)</td>
<td>微信返回的随机字符串</td>
</tr>
<tr>
<td>签名</td>
<td>sign</td>
<td>String(32)</td>
<td>微信返回的签名</td>
</tr>
<tr>
<td>业务结果</td>
<td>result_code</td>
<td>String(16)</td>
<td>SUCCESS&#x2F;FAIL</td>
</tr>
</tbody></table>
<p>return_code 和result_code都为SUCCESS时返回：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th align="center">变量名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>交易类型</td>
<td align="center">trade_type</td>
<td>String(16)</td>
<td>调用接口提交的交易类型(MWEB)</td>
</tr>
<tr>
<td>预支付交易会话标识</td>
<td align="center">prepay_id</td>
<td>String(64)</td>
<td>微信生成的预支付回话标识，用于后续接口调用中使用，有效期2小时,针对H5支付此参数无特殊用途</td>
</tr>
<tr>
<td>支付跳转链接</td>
<td align="center">mweb_url</td>
<td>String(64)</td>
<td>mweb_url为拉起微信支付收银台的中间页面，可通过访问该url来拉起微信客户端，完成支付,mweb_url的有效期为5分钟。</td>
</tr>
</tbody></table>
<p><strong><a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=9_20&index=1">错误码</a></strong></p>
<ol start="4">
<li>中间页进行H5权限的校验，安全性检查（<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4">常见问题</a>）</li>
<li>如支付成功，商户后台会接收到微信侧的异步通知</li>
<li>用户在完成支付或取消支付后返回商户页面</li>
<li>商户在展示页面引导用户发起支付结果查询</li>
<li>商户后台判断是否接收到微信侧的支付结果，没有可调用<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=9_2&index=2">订单查询接口</a>确认</li>
<li>展示最终的订单支付结</li>
</ol>
<h2 id="🎈接口规则"><a href="#🎈接口规则" class="headerlink" title="🎈接口规则"></a>🎈接口规则</h2><h3 id="⚡协议规则"><a href="#⚡协议规则" class="headerlink" title="⚡协议规则"></a>⚡协议规则</h3><ul>
<li>传输方式：采用HTTPS传输，保证交易安全性</li>
<li>提交方式：采用POST方法提交</li>
<li>数据格式：提交和返回数据都为XML格式，根节点名为xml</li>
<li>字符编码：统一采用UTF-8字符编码</li>
<li>签名算法：MD5</li>
<li>签名要求：请求和接收均需校验签名（签名算法）</li>
<li>证书要求：调用申请退款、撤销订单接口需要商户证书</li>
<li>判断逻辑：先判断协议字段返回，在判断业务返回，最后判断交易状态</li>
</ul>
<h3 id="⚡安全规范"><a href="#⚡安全规范" class="headerlink" title="⚡安全规范"></a>⚡安全规范</h3><ol>
<li>使用签名算法</li>
<li>随机字符串字段nonce_str使用生成随机数算法，保证签名不可预测</li>
<li>API证书（获取和使用）</li>
</ol>
<ul>
<li><p>证书文件应放在有访问权限控制的目录</p>
</li>
<li><p>证书文件名应该是复杂且不容易猜测的</p>
</li>
<li><p>服务器应该做好病毒和木马防护工作</p>
<ol start="4">
<li>客户回调API安全（通过采用HTTPS协议）<br>  5.  获取openid(标识微信用户)</li>
</ol>
</li>
</ul>
<h2 id="🎈实现思路"><a href="#🎈实现思路" class="headerlink" title="🎈实现思路"></a>🎈实现思路</h2><ol>
<li>支付前的一顿操作……..</li>
<li>点某个按钮触发跳转到带有微信支付按钮的页面</li>
<li>点击微信支付后根据订单相关信息生成支付订单同时调用统一下单接口，对微信支付系统发起请求</li>
<li>微信支付系统根据请求数据生成预支付交易会话标识（prepay_id）并返回过来</li>
<li>:star:构造微信支付所需参数（请求参数见上）后调用统一下单接口向微信支付发起下单请求</li>
</ol>
<ul>
<li><p>trade_type&#x3D;MWEB</p>
</li>
<li><p>生成签名：将发送的参数按参数名ASCII码从大到小排序，使用键值对的格式拼接成字符串，然后在字符串后拼接key得到新的字符串并进行MD5运算</p>
</li>
<li><p>生成随机字符串：调用随机数函数生成，将得到的值转换为字符串。</p>
</li>
<li><p>获取用户端ip：获取’REMOTE_ADDR ‘（无代理情况）</p>
</li>
<li><p>场景信息(WAP网站应用)：</p>
<pre><code> &#123;
   &quot;h5_info&quot;: //h5支付固定传&quot;h5_info&quot;
      &#123; &quot;type&quot;: &quot;&quot;, //场景类型
        &quot;wap_url&quot;: &quot;&quot;,//WAP网站URL地址
        &quot;wap_name&quot;: &quot;&quot; //WAP 网站名
      &#125;
 &#125;
</code></pre>
</li>
<li><p>通知地址：接收微信支付异步通知回调地址notify_url</p>
</li>
</ul>
<ol start="6">
<li><p>统一下单接口返回支付相关参数（支付跳转url：meb_url）给商户后台</p>
</li>
<li><p>通过mweb_url调起微信支付中间页</p>
</li>
<li><p>中间页进行H5权限的校验，安全性检查</p>
</li>
<li><p>微信支付系统核验请求后提示输入支付密码</p>
</li>
<li><p>微信支付系统验证后返回支付结果后跳转回h5页面并异步通知网站支付结果，网站及时更新订单信息并在页面显示，更新订单日志</p>
</li>
<li><p>支付成功，用户收到支付凭证，商店后台收到支付成功通知</p>
</li>
</ol>
]]></content>
      <categories>
        <category>使用文档</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2024/01/11/webpack/</url>
    <content><![CDATA[<h2 id="triangular-flag-on-post-webpack"><a href="#triangular-flag-on-post-webpack" class="headerlink" title=":triangular_flag_on_post:webpack"></a>:triangular_flag_on_post:webpack</h2><blockquote>
<p>webpack是一个现代的JavaScript应用的静态模块打包工具</p>
</blockquote>
<ul>
<li>模块</li>
<li>打包</li>
</ul>
<p><img src="https://img.sky123.top/img/image-20200916170737157.png"></p>
<h4 id="round-pushpin-前端模块化"><a href="#round-pushpin-前端模块化" class="headerlink" title=":round_pushpin:前端模块化"></a>:round_pushpin:前端模块化</h4><p>模块化：模块可以理解为把代码拆分成独立的代码块或文件，每个块能实现特定的功能；然后各自封装，隔离和组织这些模块。</p>
<p>在ES6之前的模块加载器：CommonJS、ADM、CMD、UDM</p>
<ul>
<li>CommonJS：同步加载，适用于服务器，node、webpack使用</li>
<li>ADM（Asynchronous Module Definition），异步模块定义，以浏览器为目标执行环境，实现核心为用函数包装模块定义，异步加载，浏览器使用，实现的requireJS想兼容服务器和浏览器，预加载</li>
<li>CMD（Cmomon Module Definition），通用模块定义，异步加载，专注于浏览器，实现的是seaJS，使用时加载</li>
<li>UMD（Universal Module Definition），通用模块定义，AMD和commonJS的结合，可以服务端使用也可以浏览器使用</li>
</ul>
<hr>
<p>​        JavaScript文件、css、图片、JSON等等都可以被当作模块使用</p>
<p>​		 webpack可以让我们进行模块化开发，并且会帮助处理模块间的依赖关系，将其进行整合打包</p>
<h4 id="round-pushpin-打包"><a href="#round-pushpin-打包" class="headerlink" title=":round_pushpin:打包"></a>:round_pushpin:打包</h4><p>​		webpack中的各种资源模块可以打包成一个或多个包，在打包过程中会对资源进行处理，比如压缩图片，将SCSS转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等操作</p>
<h5 id="webpack与grunt-gulp的对比"><a href="#webpack与grunt-gulp的对比" class="headerlink" title="webpack与grunt&#x2F;gulp的对比"></a>webpack与grunt&#x2F;gulp的对比</h5><ul>
<li>grunt&#x2F;gulp 也被称为前端自动化任务管理工具，其核心是Task，我们可以配置一系列的 task，并且定义 task 要处理的事务（例如 ES6、ts 转化，图片压缩，scss 转成 css）之后让 grunt&#x2F;gulp 来依次执行这些 task，而且让整个流程自动化</li>
<li>webpack 更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp开发规范</title>
    <url>/2024/01/11/uniapp%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="oden-uniapp开发规范"><a href="#oden-uniapp开发规范" class="headerlink" title=":oden:uniapp开发规范"></a>:oden:<a href="https://uniapp.dcloud.io/frame?id=%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">uniapp开发规范</a></h2><p>为了实现多端兼容，综合考虑编译速度、运行性能等因素，<code>uni-app</code> 约定了如下开发规范：</p>
<ul>
<li>页面文件遵循 <a href="https://vue-loader.vuejs.org/zh/spec.html">Vue 单文件组件 (SFC) 规范</a></li>
<li>组件标签靠近小程序规范，详见<a href="https://uniapp.dcloud.io/component/README">uni-app 组件规范</a></li>
<li>接口能力（JS API）靠近微信小程序规范，但需将前缀 <code>wx</code> 替换为 <code>uni</code>，详见<a href="https://uniapp.dcloud.io/api/README">uni-app接口规范</a></li>
<li>数据绑定及事件处理同 <code>Vue.js</code> 规范，同时补充了App及页面的生命周期</li>
<li>为兼容多端运行，建议使用flex布局进行开发</li>
</ul>
<h2 id="oden-结构化规范"><a href="#oden-结构化规范" class="headerlink" title=":oden:结构化规范"></a>:oden:结构化规范</h2><h4 id="rice-cracker-默认模板："><a href="#rice-cracker-默认模板：" class="headerlink" title=":rice_cracker:默认模板："></a>:rice_cracker:默认模板：</h4><p>┌─pages                  业务页面文件存放的目录<br>│  ├─index<br>│  │  └─index.vue       index页面<br>│  └─list<br>│     └─list.vue             list页面<br>├─static                   存放应用引用的本地静态资源（如图片、视频等）的目录，ps:静态资源只能存放于此<br>├─main.js                Vue初始化入口文件<br>├─App.vue              应用配置，用来配置App全局样式以及监听 <a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">应用生命周期</a><br>├─manifest.json     配置应用名称、appid、logo、版本等打包信息，<a href="https://uniapp.dcloud.io/collocation/manifest">详见</a></p>
<p>├─pages.json          配置页面路由、导航条、选项卡等页面类信息，<a href="https://uniapp.dcloud.io/collocation/pages">详见</a><br>└─uni.scss               uni-app内置的常用样式变量</p>
<h4 id="rice-cracker-添加目录文件夹及子文件规范："><a href="#rice-cracker-添加目录文件夹及子文件规范：" class="headerlink" title=":rice_cracker:添加目录文件夹及子文件规范："></a>:rice_cracker:添加目录文件夹及子文件规范：</h4><p>├─ api                     接口，统一管理</p>
<p>├─components       符合vue组件规范的uni-app组件目录<br>│  └─comp-a.vue   可复用的a组件</p>
<p>├─filters                  过滤器，全局工具</p>
<p>├─mock                  模拟接口，临时存放</p>
<p>├─store                   vuex, 统一管理</p>
<p>├─utils                    存放自己封装的工具类函数</p>
<h4 id="rice-cracker-文件命名："><a href="#rice-cracker-文件命名：" class="headerlink" title=":rice_cracker:文件命名："></a>:rice_cracker:文件命名：</h4><ul>
<li>尽量是名词,且使用驼峰命名法</li>
<li>开头的单词就是所属模块名字（workbenchIndex、workbenchList、workbenchEdit）</li>
<li>名字至少两个单词（good: workbenchIndex）（bad:workbench）</li>
</ul>
<h2 id="oden-组件规范"><a href="#oden-组件规范" class="headerlink" title=":oden:组件规范"></a>:oden:组件规范</h2><h4 id="rice-cracker-组件文件："><a href="#rice-cracker-组件文件：" class="headerlink" title=":rice_cracker:组件文件："></a>:rice_cracker:组件文件：</h4><p>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。<br>当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。</p>
<ul>
<li><p>vue组件</p>
<ul>
<li>import导入组件</li>
<li>components里注册组件</li>
<li>template中使用组件</li>
</ul>
</li>
<li><p>easycom组件</p>
<p>组件安装在项目的components目录下或<code>uni_modules</code>目录下，并符合<code>components/组件名称/组件名称.vue</code>目录结构</p>
<p>PS：<code>easycom</code>打包后会自动剔除没有使用的组件，对组件库的使用尤为友好</p>
</li>
</ul>
<h4 id="rice-cracker-组件命名规范："><a href="#rice-cracker-组件命名规范：" class="headerlink" title=":rice_cracker:组件命名规范："></a>:rice_cracker:组件命名规范：</h4><ul>
<li>有意义的: 不过于具体，也不过于抽象</li>
<li>简短: 2 到 3 个单词</li>
<li>具有可读性: 以便于沟通交流</li>
</ul>
<p>同时还需要注意：</p>
<ul>
<li>必须符合<strong>自定义元素规范</strong>: 使用<strong>连字符</strong><code>-</code>分隔单词，切勿使用保留字（可区分页面和组件）</li>
<li>组件里面的name要和组件的名字保持一致</li>
<li><code>app-</code>前缀作为命名空间: 如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br>&lt;app-header&gt;&lt;/app-header&gt;<br>&lt;user-list&gt;&lt;/user-list&gt;<br>&lt;range-slider&gt;&lt;/range-slider&gt;<br><br>&lt;!-- 避免 --&gt;<br>&lt;btn-group&gt;&lt;/btn-group&gt; &lt;!-- 虽然简短但是可读性差. 使用 `button-group` 替代 --&gt;<br>&lt;ui-slider&gt;&lt;/ui-slider&gt; &lt;!-- ui 前缀太过于宽泛，在这里意义不明确 --&gt;<br>&lt;slider&gt;&lt;/slider&gt; &lt;!-- 与自定义元素规范不兼容 --&gt;<br></code></pre></td></tr></table></figure>

<h4 id="rice-cracker-组件数据："><a href="#rice-cracker-组件数据：" class="headerlink" title=":rice_cracker:组件数据："></a>:rice_cracker:组件数据：</h4><p>组件的 data 必须是一个函数。<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br>// In a .vue file<br>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      foo: &#x27;bar&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br>// 在一个 Vue 的根实例上直接使用对象是可以的，<br>// 因为只存在一个这样的实例。<br>new Vue(&#123;<br>  data: &#123;<br>    foo: &#x27;bar&#x27;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h4 id="rice-cracker-组件-props-原子化"><a href="#rice-cracker-组件-props-原子化" class="headerlink" title=":rice_cracker:组件 props 原子化"></a>:rice_cracker:组件 props 原子化</h4><p>为什么？</p>
<ul>
<li>使得组件 API 清晰直观</li>
<li>只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素</li>
<li>其它开发者更好的理解每一个 prop 的含义、作用</li>
<li>传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br>&lt;range-slider<br>  :values=&quot;[10, 20]&quot;<br>  :min=&quot;0&quot;<br>  :max=&quot;100&quot;<br>  :step=&quot;5&quot;<br>  @on-slide=&quot;updateInputs&quot;<br>  @on-end=&quot;updateResults&quot;&gt;<br>&lt;/range-slider&gt;<br><br>&lt;!-- 避免 --&gt;<br>&lt;range-slider :config=&quot;complexConfigObject&quot;&gt;&lt;/range-slider&gt;<br></code></pre></td></tr></table></figure>

<h4 id="rice-cracker-将-this-赋值给-component-变量"><a href="#rice-cracker-将-this-赋值给-component-变量" class="headerlink" title=":rice_cracker:将 this 赋值给 component 变量"></a>:rice_cracker:将 this 赋值给 component 变量</h4><p>在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。</p>
<p>换句话说，如果你正在使用 <code>ES6</code> 的话，就不要再编写 var self &#x3D; this; 这样的代码了，你可以安全地使用 Vue 组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br>&lt;script type=&quot;text/javascript&quot;&gt;<br>export default &#123;<br>  methods: &#123;<br>    hello() &#123;<br>      return &#x27;hello&#x27;;<br>    &#125;,<br>    printHello() &#123;<br>      console.log(this.hello());<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br>&lt;!-- 避免 --&gt;<br>&lt;script type=&quot;text/javascript&quot;&gt;<br>export default &#123;<br>  methods: &#123;<br>    hello() &#123;<br>      return &#x27;hello&#x27;;<br>    &#125;,<br>    printHello() &#123;<br>      const self = this; // 没有必要<br>      console.log(self.hello());<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h2 id="oden-编码规范"><a href="#oden-编码规范" class="headerlink" title=":oden:编码规范"></a>:oden:编码规范</h2><h4 id="rice-cracker-变量命名要求"><a href="#rice-cracker-变量命名要求" class="headerlink" title=":rice_cracker:变量命名要求"></a>:rice_cracker:变量命名要求</h4><ul>
<li>定义变量使用<code> let</code> ,定义常量使用<code> const</code></li>
<li>命名方法 : 变量使用驼峰命名法</li>
</ul>
<h4 id="rice-cracker-常量命名要求"><a href="#rice-cracker-常量命名要求" class="headerlink" title=":rice_cracker:常量命名要求"></a>:rice_cracker:常量命名要求</h4><ul>
<li>命名方法: 全部大写</li>
<li>命名规范: 使用大写字母和下划线来组合命名，下划线用以分割单词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">const MAX_COUNT = 10<br>const URL = &#x27;https://www.baidu.com/&#x27;<br></code></pre></td></tr></table></figure>

<h4 id="rice-cracker-解构赋值"><a href="#rice-cracker-解构赋值" class="headerlink" title=":rice_cracker:解构赋值"></a>:rice_cracker:解构赋值</h4><ul>
<li>数组成员对变量赋值时，优先使用解构赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组解构赋值</span><br> <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br> <span class="hljs-comment">// bad</span><br> <span class="hljs-keyword">const</span> first = arr[<span class="hljs-number">0</span>]<br> <span class="hljs-keyword">const</span> second = arr[<span class="hljs-number">1</span>]<br><br> <span class="hljs-comment">// good</span><br> <span class="hljs-keyword">const</span> [first, second] = arr<br></code></pre></td></tr></table></figure>

<ul>
<li>函数的参数如果是对象的成员，优先使用解构赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象解构赋值</span><br>  <span class="hljs-comment">// bad</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params">user</span>) &#123;<br>    <span class="hljs-keyword">const</span> firstName = user.<span class="hljs-property">firstName</span><br>    <span class="hljs-keyword">const</span> lastName = user.<span class="hljs-property">lastName</span><br>  &#125;<br><br>  <span class="hljs-comment">// good</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; firstName, lastName &#125; = obj<br>  &#125;<br><br>  <span class="hljs-comment">// best</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params">&#123; firstName, lastName &#125;</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>拷贝数组</p>
<p>使用扩展运算符（…）拷贝数组。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br> <span class="hljs-comment">// bad</span><br> <span class="hljs-keyword">const</span> itemsCopy = items<br><br> <span class="hljs-comment">// good</span><br> <span class="hljs-keyword">const</span> itemsCopy = [...items]<br></code></pre></td></tr></table></figure>

<ul>
<li><p>箭头函数</p>
<p>需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">const</span> boundMethod = <span class="hljs-keyword">function</span>(<span class="hljs-params">...params</span>) &#123;<br>    <span class="hljs-keyword">return</span> method.<span class="hljs-title function_">apply</span>(self, params);<br>  &#125;<br><br>  <span class="hljs-comment">// acceptable</span><br>  <span class="hljs-keyword">const</span> boundMethod = method.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br><br>  <span class="hljs-comment">// best</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">boundMethod</span> = (<span class="hljs-params">...params</span>) =&gt; method.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, params);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>模块</p>
<ul>
<li>如果模块只有一个输出值，就使用 export default，如果模块有多个输出值，就不使用 export default，export default 与普通的 export 不要同时使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myObject <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./importModule&#x27;</span><br>  <br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">import</span> myObject <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./importModule&#x27;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>如果模块默认输出一个函数，函数名的首字母应该小写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeStyleGuide</span>(<span class="hljs-params"></span>) &#123;<br> <br>&#125;<br><br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> makeStyleGuide;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果模块默认输出一个对象，对象名的首字母应该大写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">StyleGuide</span> = &#123;<br>    <span class="hljs-attr">es6</span>: &#123;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">StyleGuide</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="rice-cracker-method-方法命名命名规范"><a href="#rice-cracker-method-方法命名命名规范" class="headerlink" title=":rice_cracker:method 方法命名命名规范"></a>:rice_cracker:method 方法命名命名规范</h4><ul>
<li>驼峰式命名，统一使用动词或者动词+名词形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br> jumpPage、openCarInfoDialog <br>&lt;!-- 避免 --&gt;<br> go、nextPage、show、open、login<br></code></pre></td></tr></table></figure>

<ul>
<li>如果是请求什么数据的需要以data来结尾</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br> getListData、postFormData <br>&lt;!-- 避免 --&gt;<br> takeData、confirmData、getList、postForm<br></code></pre></td></tr></table></figure>

<ul>
<li>尽量使用常用单词开头（set、get、go、can、has、is）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">get 获取/set 设置,<br>add 增加/remove 删除<br>create 创建/destory 移除<br>start 启动/stop 停止<br>open 打开/close 关闭,<br>read 读取/write 写入<br>load 载入/save 保存,<br>create 创建/destroy 销毁<br>begin 开始/end 结束,<br>backup 备份/restore 恢复<br>import 导入/export 导出,<br>split 分割/merge 合并<br>inject 注入/extract 提取,<br>attach 附着/detach 脱离<br>bind 绑定/separate 分离,<br>view 查看/browse 浏览<br>edit 编辑/modify 修改,<br>select 选取/mark 标记<br>copy 复制/paste 粘贴,<br>undo 撤销/redo 重做<br>insert 插入/delete 移除,<br>add 加入/append 添加<br>clean 清理/clear 清除,<br>index 索引/sort 排序<br>find 查找/search 搜索,<br>increase 增加/decrease 减少<br>play 播放/pause 暂停,<br>launch 启动/run 运行<br>compile 编译/execute 执行,<br>debug 调试/trace 跟踪<br>observe 观察/listen 监听,<br>build 构建/publish 发布<br>input 输入/output 输出,<br>encode 编码/decode 解码<br>encrypt 加密/decrypt 解密,<br>compress 压缩/decompress 解压缩<br>pack 打包/unpack 解包,<br>parse 解析/emit 生成<br>connect 连接/disconnect 断开,<br>send 发送/receive 接收<br>download 下载/upload 上传,<br>refresh 刷新/synchronize 同步<br>update 更新/revert 复原,<br>lock 锁定/unlock 解锁<br>check out 签出/check in 签入,<br>submit 提交/commit 交付<br>push 推/pull 拉,<br>expand 展开/collapse 折叠<br>begin 起始/end 结束,<br>start 开始/finish 完成<br>enter 进入/exit 退出,<br>abort 放弃/quit 离开<br>obsolete 废弃/depreciate 废旧,<br>collect 收集/aggregate 聚集<br></code></pre></td></tr></table></figure>

<ul>
<li><p>props 命名</p>
<p>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板中应该始终使用 kebab-case</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- bad --&gt;<br>&lt;script&gt;<br>props: &#123;<br>  &#x27;greeting-text&#x27;: String<br>&#125;<br>&lt;/script&gt;<br><br>&lt;welcome-message greetingText=&quot;hi&quot;&gt;&lt;/welcome-message&gt;<br><br>&lt;!-- good --&gt;<br>&lt;script&gt;<br>props: &#123;<br>  greetingText: String<br>&#125;<br>&lt;/script&gt;<br><br>&lt;welcome-message greeting-text=&quot;hi&quot;&gt;&lt;/welcome-message&gt;<br></code></pre></td></tr></table></figure>

<p>PS:特殊情况</p>
<ul>
<li>作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。</li>
<li>循环变量可以简写，比如：i，j，k 等。</li>
</ul>
</li>
<li><p>为v-for设置键值</p>
<p>总是用 key 配合 v-for。<br>在组件上_总是_必须用 key 配合 v-for，以便维护内部组件及其子树的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br>&lt;ul&gt;<br>  &lt;li<br>    v-for=&quot;todo in todos&quot;<br>    :key=&quot;todo.id&quot;<br>  &gt;<br>    &#123;&#123; todo.text &#125;&#125;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>避免 v-if 和 v-for 用在一起</p>
<p>永远不要把 v-if 和 v-for 同时用在同一个元素上。<br> 一般我们在两种常见的情况下会倾向于这样做：</p>
<ul>
<li>为了过滤一个列表中的项目 (比如 v-for&#x3D;”user in users” v-if&#x3D;”user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</li>
<li>为了避免渲染本应该被隐藏的列表 (比如 v-for&#x3D;”user in users” v-if&#x3D;”shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- 推荐 --&gt;<br>&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;<br>  &lt;li<br>    v-for=&quot;user in users&quot;<br>    :key=&quot;user.id&quot;<br>  &gt;<br>    &#123;&#123; user.name &#125;&#125;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>指令缩写</p>
<p>都用指令缩写 (用 : 表示 v-bind: 和用 @ 表示 v-on:)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">// bad<br>  v-bind:class=&quot;&#123;&#x27;show-left&#x27;：true&#125;&quot;<br>  v-on:click=&quot;getListData&quot;<br><br>// good<br>  :class=&quot;&#123;&#x27;show-left&#x27;：true&#125;&quot;<br>  @click=&quot;getListData&quot;<br></code></pre></td></tr></table></figure>
</li>
<li><p>多个特性的元素规范</p>
<p>多个特性的元素应该分多行撰写，每个特性一行。(增强更易读)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;!-- bad --&gt;<br>&lt;img src=&quot;https://vuejs.org/images/logo.png&quot; alt=&quot;Vue Logo&quot;&gt;<br>&lt;my-component foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;&gt;&lt;/my-component&gt;<br><br>&lt;!-- good --&gt;<br>&lt;img<br>  src=&quot;https://vuejs.org/images/logo.png&quot;<br>  alt=&quot;Vue Logo&quot;<br>&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>元素特性的顺序</p>
<p>原生属性放前面，指令放后面</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-bullet">-</span> <span class="hljs-string">class</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">id,ref</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">data-*</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">src, for, type, href,value,max-length,max,min,pattern</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">title, alt，placeholder</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">aria-*, role</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">required,readonly,disabled</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">is</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-for</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">key</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-if</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-else-if</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-else</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-show</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-cloak</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-pre</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-once</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-model</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-bind,:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-on,@</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-html</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">v-text</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="rice-cracker-其他"><a href="#rice-cracker-其他" class="headerlink" title=":rice_cracker:其他"></a>:rice_cracker:其他</h4><ul>
<li>避免 this.$parent</li>
<li>调试信息 console.log() debugger 使用完及时删除</li>
<li>除了三目运算，if,else 等禁止简写</li>
</ul>
<h2 id="oden-注释规范"><a href="#oden-注释规范" class="headerlink" title=":oden:注释规范"></a>:oden:注释规范</h2><p>​    代码注释在一个项目的后期维护中显的尤为重要，所以我们要为每一个被复用的组件编写组件使用说明，为组件中每一个方法编写方法说明</p>
<h4 id="rice-cracker-务必添加注释列表"><a href="#rice-cracker-务必添加注释列表" class="headerlink" title=":rice_cracker:务必添加注释列表"></a>:rice_cracker:务必添加注释列表</h4><ul>
<li>公共组件使用说明</li>
<li>各组件中重要函数或者类说明</li>
<li>复杂的业务逻辑处理说明</li>
<li>特殊情况的代码处理说明,对于代码中特殊用途的变量、存在临界值、函数中使用的 hack、使用了某种算法或思路等需要进行注释描述</li>
<li>多重 if 判断语句</li>
<li>注释块必须以<code>/**（至少两个星号开头）**/</code></li>
<li>单行注释使用<code>//</code></li>
</ul>
<h2 id="oden-CSS规范"><a href="#oden-CSS规范" class="headerlink" title=":oden:CSS规范"></a>:oden:CSS规范</h2><ul>
<li><p>统一使用<code>-</code>连字符</p>
</li>
<li><p>省略值为 0 时的单位</p>
</li>
<li><p>如果 CSS 可以做到，就不要使用 JS</p>
</li>
<li><p>建议并适当缩写值，提高可读性，特殊情况除外</p>
<p>“建议并适当”是因为缩写总是会包含一系列的值，而有时候我们并不希望设置某一值，反而造成了麻烦，那么这时候你可以不缩写，而是分开写。</p>
<p>当然，在一切可以缩写的情况下，请务必缩写，它最大的好处就是节省了字节，便于维护，并使阅读更加一目了然</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">// bad<br>  <span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">border-top-style</span>: none;<br>    <span class="hljs-attribute">font-family</span>: palatino, georgia, serif;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">1em</span>;<br>    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">1em</span>;<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">0</span>;<br>  &#125;<br><br>  // good<br>  <span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span>/<span class="hljs-number">1.6</span> palatino, georgia, serif;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">2em</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>分类的命名方法</p>
<ul>
<li>使用单个字母加上<code>-</code>为前缀</li>
<li>布局（grid）（.g-）</li>
</ul>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/wps1.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>模块（module）（.m-）</li>
</ul>
<p><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/wps2.jpg" alt="img"></p>
<ul>
<li>元件（unit）（.u-）</li>
<li>功能（function）（.f-）</li>
</ul>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/wps3.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>皮肤（skin）（.s-）</li>
</ul>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/wps4.jpg" alt="img" style="zoom:50%;" />

<ul>
<li><p>状态（.z-）</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/wps5.jpg" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发文档</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Docker</title>
    <url>/2024/01/11/%E4%BA%86%E8%A7%A3Docker/</url>
    <content><![CDATA[<h2 id="了解Docker"><a href="#了解Docker" class="headerlink" title="了解Docker"></a>了解Docker</h2><p>Docker是一个开源的<code>应用容器引擎</code>，让开发者可以打包他们的应用以及依赖到一个<code>可移植</code>的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上，也可以实现<code>虚拟化</code>，容器是完全使用<code>沙箱机制</code>，相互之间不会有任何接口</p>
<p>一个完整的Docker有以下几个部分组成：</p>
<ul>
<li>DockerClient客户端</li>
<li>Docker Daemon守护进程</li>
<li>Docker Image镜像</li>
<li>DockerContainer容器</li>
</ul>
<p>PS：来自百度百科（Docker的简介）</p>
<h3 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h3><p>学习视频：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=1">Docker最新超详细版教程</a></p>
<p>参考文档：<a href="https://blog.sky123.top/2021/05/04/docker/Docker01%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/">Docker的概述和安装</a></p>
<p>Docker是基于<code>GO语言</code>开发的开源项目</p>
<p>一些学习地址：</p>
<ul>
<li><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
</li>
<li><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
</li>
<li><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
</li>
</ul>
<h4 id="Docker与虚拟机的比较"><a href="#Docker与虚拟机的比较" class="headerlink" title="Docker与虚拟机的比较"></a>Docker与虚拟机的比较</h4><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20210422115546688.png" style="zoom:50%;" />

<p>PS：虚拟机技术</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20210422115733382.png" style="zoom:50%;" />

<p>PS：Docker容器化技术</p>
<ul>
<li>传统虚拟机：虚拟出一系列硬件，运行一个完整的操作系统，然后在这个系统安装和运行软件</li>
<li>容器内的应用直接运行在宿主机上，容器没有自己的内核，也没有虚拟出硬件，十分轻便</li>
<li>每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响</li>
</ul>
<h4 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h4><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20210221182251636.png" style="zoom:50%;" />

<p>基本概念：</p>
<ul>
<li><p>镜像（image）：docker镜像可以比作一个模板，可以通过这个模板创建容器服务，tomcat镜像→run→tomcat01容器，通过镜像可以创建多个容器（最终服务运行或项目运行就是在容器中）</p>
</li>
<li><p>容器（container）：docker利用容器技术，独立地运行一个或一组应用，通过image来创建</p>
<p>启动、停止、删除等基本命令</p>
<p>PS：可以蒋容器理解为一个简单的Linux系统</p>
</li>
<li><p>仓库（repository）：仓库是存放镜像的地方，有公有和私有仓库之分</p>
<p>PS：Docker Hub（默认是国外的），阿里云等平台都有容器服务器（配置镜像加速）</p>
</li>
</ul>
<h4 id="Docker作用"><a href="#Docker作用" class="headerlink" title="Docker作用"></a>Docker作用</h4><p>可以实现<code>DevOps</code>（开发，运维）</p>
<ul>
<li>应用更快速的交付和部署：打包镜像发布测试，一键运行</li>
<li>更便捷的升级和扩缩容：使用Docker，部署像搭积木一样，项目打包为一个镜像，方便扩展</li>
<li>更简单的系统运维：在容器化之后，开发和测试环境都是高度一致的</li>
<li>更高效的计算资源利用：Docker是内核级别的虚拟化，可以在一个物理机上运行多个容器实例，容器的性能可以被压榨到极致</li>
</ul>
<h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul>
<li>Linux操作系统</li>
<li>Xshell（连接远程服务器）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看系统内核(系统内核3.10以上的)</span><br>uname -r<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看系统信息</span><br>cat /etc/os-release<br></code></pre></td></tr></table></figure>

<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>官网安装文档：<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p>
<h5 id="CentOS系统"><a href="#CentOS系统" class="headerlink" title="CentOS系统"></a>CentOS系统</h5><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">卸载旧版本Docker系统（如果有点话）</span><br>sudo yum remove docker\<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装需要的安装包</span><br>yum install -y yum-utils<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置下载Docker镜像</span><br>sudo yum-config-manager\<br>   --add-repo\<br>    https://download.docker.com/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装docker，一路输入确定安装即可</span><br>sudo yum install docker-ce docker-ce-li containerd.io<br></code></pre></td></tr></table></figure>

<h4 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看docker是否安装成功和版本</span><br>docker -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动docker</span><br>systemctl start docker<br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行测试</span><br>docker run hello-world<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看下载的hello-world镜像</span><br>docker images<br></code></pre></td></tr></table></figure>

<h4 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">卸载</span><br>yum remove docker-ce docker-ce-li containerd.io<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除文件(/var/lib/docker时是docker的默认工作路径)</span><br>rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure>

<h4 id="Docker配置阿里云镜像仓库地址"><a href="#Docker配置阿里云镜像仓库地址" class="headerlink" title="Docker配置阿里云镜像仓库地址"></a>Docker配置阿里云镜像仓库地址</h4><p>参考教程：<a href="https://www.cnblogs.com/allenjing/p/12575972.html">https://www.cnblogs.com/allenjing/p/12575972.html</a></p>
<ul>
<li>登录阿里云找到容器镜像服务</li>
<li>选择镜像加速器复制加速器地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;:[&quot;https://bjyjzfeq.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure>

<h4 id="Docker运行原理"><a href="#Docker运行原理" class="headerlink" title="Docker运行原理"></a>Docker运行原理</h4><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20210428121520142.png" style="zoom: 67%;" />

<h5 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h5><p>Docker工作原理：Docker是一个<code>CS结构</code>的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问</p>
<p>DockerServer接收到DockerClient的指令，就会执行这个命令</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20210428122527218.png" style="zoom:67%;" />

<h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">显示版本</span><br>docker version<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示Docker的系统信息</span><br>docker info<br><span class="hljs-meta prompt_">#</span><span class="language-bash">帮助信息</span><br>docker --help<br>Commands:<br>  attach     # 当前 shell 下 attach 连接指定运行镜像 <br>  build      # 通过 dokcerfile 定制镜像 <br>  commit     # 提交当前容器为新的镜像 <br>  cp         # 从容器中拷贝指定文件或目录到宿主机 <br>  create     # 创建一个新的容器 ，同 run ，但不会启动容器 <br>  diff       # 查看 docker 容器变化 <br>  events     # 从 docker 服务器获取容器实时事件 <br>  exec       # 在已存在的容器上运行命令 <br>  export     # 导出容器的内容流作为一个 tar 归档文件（对应 import）<br>  history    # 展示镜像的形成历史 <br>  images     # 列出系统当前所有镜像 <br>  import     # 从 tar 包中的内容创建一个新的文件系统映像（对应 export）<br>  info       # 查看系统相关信息 <br>  inspect    # 查看容器详细信息 <br>  kill       #kill 指定的 docker 容器 <br>  load       # 从一个 tar 包中加载一个镜像（对应 save）<br>  login      # 注册或登陆一个 docker 源服务器 <br>  logout     # 登出当前源服务器 <br>  logs       # 输出当前容器的日志内容 <br>  pause      # 暂停容器 <br>  port       # 查看映射端口对应的容器内部源端口 <br>  ps         # 列出容器列表 <br>  pull       # 从 docker 镜像源服务器拉取指定镜像或库镜像 <br>  push       # 推送指定镜像或者库镜像到 docker 源服务器 <br>  rename     #<br>  restart    # 重启运行的容器 <br>  rm         # 移除一个或多个容器 <br>  rmi        # 移除一个或多个镜像 <br>  run        # 创建一个新的容器并运行一个命令 <br>  save       # 保存一个镜像为一个 tar (对应 load)<br>  search     # 在 docker hub 中搜索镜像 <br>  start      # 启动容器 <br>  stop       # 停止容器 <br>  tag        # 给源镜像打标签 <br>  top        # 查看容器中运行的进程消息 <br>  unpause    # 取消暂停容器 <br>  version    # 查看容器版本号 <br>  wait       # 获取容器停止时的退出状态值 <br><br></code></pre></td></tr></table></figure>

<h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><ul>
<li>docker images</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">主机上的所有本地镜像</span><br>docker images help<br>REPOSITORY   TAG       IMAGE ID   CREATED   SIZE<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解释</span> <br>REPOSITORY：镜像的仓库源   <br>TAG：镜像的标签 <br>IMAGE ID：镜像的 ID   <br>CREATED：创建时间   <br>SIZE：大小 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项</span> <br>-a   --all # 列出所有镜像 <br>-q   --quiet # 只列出镜像的 ID<br>docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE<br>hello-world   latest    feb5d9fea6a5   2 months ago   13.3kB<br></code></pre></td></tr></table></figure>

<ul>
<li>docker search</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索镜像</span><br>docker search hello-world<br><span class="hljs-meta prompt_">#</span><span class="language-bash">搜索镜像的star&gt;1000的镜像</span><br>docker search hello-world --filter=stars=3000<br></code></pre></td></tr></table></figure>

<ul>
<li>docker pull</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载镜像[:tag]  (不写tag默认就是latest)</span><br>docker pull mysql<br><span class="hljs-meta prompt_">#</span><span class="language-bash">等价写法 (docker.io/library/mysql:latest为存放的镜像的文件真实地址)</span><br>docker pull docker.io/library/mysql:latest<br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载指定版本</span><br>docker pull mysql:5.7<br></code></pre></td></tr></table></figure>

<ul>
<li>docker rmi</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">删除镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker rmi 镜像 ID [镜像 ID,...]   删除没有运行容器的镜像</span><br>docker rmi bbf6571db497<br><span class="hljs-meta prompt_">#</span><span class="language-bash">docker rmi -f 镜像 ID [镜像 ID,...]  删除连带删除容器的镜像</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">docker rmi -f $(docker images -aq)  删除所有容器和镜像</span> <br></code></pre></td></tr></table></figure>

<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">前置环境：下载一个centos镜像</span><br>docker pull centos<br><span class="hljs-meta prompt_">#</span><span class="language-bash">新建并运行容器</span><br>docker run --help<br>docker run -it centos /bin/bash<br><span class="hljs-meta prompt_">#</span><span class="language-bash">列出所有运行的容器</span><br>docker ps<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-q 只显示容器编号，-a 列出当前正在运行的容器+带出历史运行过的容器，-n=? 显示最新常见的容器的个数</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">直接容器停止并退出</span><br>exit<br><span class="hljs-meta prompt_">#</span><span class="language-bash">容器不停止而退出</span><br>Ctrl+P+Q<br></code></pre></td></tr></table></figure>

<ul>
<li>删除容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定的容器，<span class="hljs-built_in">rm</span> -f 表示强制删除正在运行的容器</span> <br>docker rm [-f] 容器 ID <br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有的容器</span> <br>docker rm -f $(docker ps -aq)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有容器</span><br>docker ps -a -q|xargs docker rm <br></code></pre></td></tr></table></figure>

<ul>
<li>启动停止容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span> <br>docker start 容器 ID <br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span> <br>docker restart 容器 ID <br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止正在运行的容器</span><br>docker stop 容器 ID  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">强制停止当前运行的容器</span><br>docker kill 容器 ID  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台启动容器</span><br>docker run -d centos<br></code></pre></td></tr></table></figure>

<p>常见问题：-d 运行之后，docker ps 发现它并没有运行 </p>
<p>原因：docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止 </p>
<p>nginx 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了。</p>
<ul>
<li>查看容器进程的信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker top 018801a5cdcf<br></code></pre></td></tr></table></figure>

<ul>
<li>查看镜像中的元数据</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> inspect <span class="hljs-number">018801</span>a5cdcf <br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用VMware安装Centos7环境</title>
    <url>/2024/01/11/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85Centos7%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="使用VMware安装Centos7环境"><a href="#使用VMware安装Centos7环境" class="headerlink" title="使用VMware安装Centos7环境"></a>使用VMware安装Centos7环境</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>先分别将VMware、Centos7、Xshell和Xftp安装好</p>
<p>基本都是直接下一步</p>
<p>PS：VMware最好取消更新</p>
<p>链接：<a href="https://pan.baidu.com/s/1FPxg2RHu9HiUdsgUSL3Eaw">https://pan.baidu.com/s/1FPxg2RHu9HiUdsgUSL3Eaw</a><br>提取码：rg21</p>
<h5 id="许可证密钥："><a href="#许可证密钥：" class="headerlink" title="许可证密钥："></a>许可证密钥：</h5><p>UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA<br>VF750-4MX5Q-488DQ-9WZE9-ZY2D6<br>UU54R-FVD91-488PP-7NNGC-ZFAX6<br>YC74H-FGF92-081VZ-R5QNG-P6RY4<br>YC34H-6WWDK-085MQ-JYPNX-NZRA2</p>
<h5 id="Centos7镜像下载链接："><a href="#Centos7镜像下载链接：" class="headerlink" title="Centos7镜像下载链接："></a>Centos7镜像下载链接：</h5><p><a href="https://vault.centos.org/7.6.1810/isos/x86_64/">https://vault.centos.org/7.6.1810/isos/x86_64/</a></p>
<h5 id="Xshell和Xftp下载链接："><a href="#Xshell和Xftp下载链接：" class="headerlink" title="Xshell和Xftp下载链接："></a>Xshell和Xftp下载链接：</h5><p><a href="https://www.netsarang.com/zh/free-for-home-school/">https://www.netsarang.com/zh/free-for-home-school/</a></p>
<h3 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h3><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106214522521.png" alt="" style="zoom: 67%;" />

<p>PS：给虚拟机留足空间，同时防止C盘崩盘</p>
<p><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106214846368.png"></p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106214926935.png" alt="" style="zoom:67%;" />

<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215006283.png" alt="" style="zoom:67%;" /> </p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215052987.png" alt="" style="zoom:67%;" /></p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215155906.png" alt="" style="zoom:67%;" /></p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215301406.png" alt="" style="zoom:67%;" /></p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215341330.png" alt="" style="zoom:67%;" /></p>
<p>PS：虚拟机内存根据计算机内存定</p>
<p>​                                            <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215418966.png" alt="" style="zoom:67%;" /></p>
<p>PS：桥接网络和NAT的区别</p>
<ul>
<li><p>bridged（桥接模式）</p>
<ul>
<li><p>VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器</p>
</li>
<li><p>使用桥接模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑</p>
</li>
<li><p>当前主机IP为192.168.8.100  虚拟机192.168.8.xxx</p>
<p>PPS：这种模式虚拟机和主机之间可以相互访问但可能会出现IP冲突</p>
</li>
</ul>
</li>
<li><p>NAT（网络地址转换模式）</p>
<ul>
<li>使用NAT模式，就是让虚拟系统借助NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网</li>
<li>NAT模式下的虚拟系统的TCP&#x2F;IP配置信息是由VMnet8（NAT）虚拟网络的DHCP服务器提供的</li>
<li>虚拟系统也就无法和本局域网中的其他真实主机进行通讯</li>
</ul>
<p><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211107092357754.png"></p>
</li>
</ul>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215546097.png" alt="" style="zoom:67%;" /></p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215611500.png" alt="" style="zoom:67%;" /></p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215640820.png" alt="" style="zoom:67%;" /></p>
<p>​                                           <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106215850257.png" alt="" style="zoom:67%;" /></p>
<p>PS：磁盘太小很可能不够用</p>
<p>​                                          <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106220223592.png" alt="" style="zoom:67%;" /></p>
<p>​                                          <img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106220257149.png" alt="" style="zoom:67%;" /></p>
<p>启动虚拟机</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106220453988.png" alt="" style="zoom: 67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106220650300.png" alt="" style="zoom:67%;" />

<h3 id="安装操作系统（Centos7）"><a href="#安装操作系统（Centos7）" class="headerlink" title="安装操作系统（Centos7）"></a>安装操作系统（Centos7）</h3><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106220911452.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106221046127.png" alt="" style="zoom:67%;" />

<p>再次开启虚拟机，此时虚拟机存在光驱，光驱里有一个光盘（光盘就是系统）</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106221428316.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106221604121.png" alt="" style="zoom:67%;" />

<p>PS：选择英文可以避免很多bug（中文可能出现乱码）</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106221842834.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222007730.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222237537.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222354824.png" alt="image-20211106222354824" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222436060.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222533110.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222641871.png" alt="image-20211106222641871" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222907708.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106222830453.png" alt="" style="zoom:67%;" />

<p>Done之后点击Begin Installation</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106223211112.png" alt="" style="zoom:67%;" />

<p>PS：用户名直接用root，密码尽可能简单</p>
<p>安装会需要一段时间，安装完成后点击Reboot(重启)</p>
<p><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211106223743066.png"></p>
<p>输入用户名和密码后即可进入</p>
<h3 id="配置虚拟机网络信息"><a href="#配置虚拟机网络信息" class="headerlink" title="配置虚拟机网络信息"></a>配置虚拟机网络信息</h3><img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211107094423625.png" alt="" style="zoom:67%;" />

<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211107094700810.png" alt="" style="zoom:67%;" />

<p>配置网关时需要用到</p>
<p>PS：虚拟机配配置IP时应该避免使用xxx.xxx.xxx.0、xxx.xxx.xxx.1、xxx.xxx.xxx.2、xxx.xxx.xxx.255 （用100左右的），以免出现端口占用</p>
<ul>
<li>修改网络信息</li>
</ul>
<p>进入文本编辑</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"># vi <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33<br></code></pre></td></tr></table></figure>

<p>DD-删除该行</p>
<p>i-修改文本</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211107102739816.png" alt="" style="zoom:67%;" />

<p>按<code>Esc</code>推出编辑</p>
<p>输入<code>:wq</code>后回车保存</p>
<ul>
<li><p>重启网卡重新加载配置文件并测试</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># ip addr</span><br><span class="hljs-meta"># systemctl restart network.service</span><br><span class="hljs-meta"># ping www.baidu.com</span><br></code></pre></td></tr></table></figure>

<p><code>ctrl+c </code>终止命令的执行</p>
</li>
</ul>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211107102444125.png" alt="" style="zoom:67%;" />

<p>成功解决网络问题~</p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul>
<li><p>保护本机的端口不被他人访问</p>
</li>
<li><p>如果端口需要被别人访问到，需要添加端口的防火墙例外</p>
</li>
<li><p>查看防火墙状态</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># systemctl status firewalld</span><br></code></pre></td></tr></table></figure>

<p>为开启状态时：</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/firewall.JPG" style="zoom: 80%;" />
</li>
<li><p>关闭防火墙（所有端口都能被访问到【危】）</p>
<ul>
<li><p>本次开机状态下防火墙关闭</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># systemctl stop firewalld  </span><br></code></pre></td></tr></table></figure>

<p>本次服务内关闭防火墙</p>
<p>关闭防火墙后：</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/firewall2.JPG" style="zoom:80%;" />
</li>
<li><p>服务器重启后防火墙禁用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl <span class="hljs-built_in">disable</span> firewalld</span><br></code></pre></td></tr></table></figure>

<p>禁用防火墙服务</p>
</li>
</ul>
</li>
</ul>
<h3 id="软件安装限制"><a href="#软件安装限制" class="headerlink" title="软件安装限制"></a>软件安装限制</h3><ul>
<li><p>操作系统对未知软件的安装有可能拒绝或者警告，需要禁用这个功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vi /etc/selinux/config</span><br></code></pre></td></tr></table></figure>

<ul>
<li>SELINUX&#x3D;disabled</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Electron</title>
    <url>/2024/01/11/%E5%88%9D%E8%AF%86Electron/</url>
    <content><![CDATA[<h2 id="初识Electron"><a href="#初识Electron" class="headerlink" title="初识Electron"></a>初识Electron</h2><p>​      Electron是一个JavaScript、HTML、CSS构建桌面应用程序的框架。通过将Chromium和Node.js嵌入到它的二进制文件中，Electron允许维护一个JavaScript代码库并创建可在Windows、macOS、Linux上运行的跨平台应用程序——无需本地开发经验。</p>
<p>本质上为浏览器内置了Node环境，从而可以控制本地文件</p>
<p>PS：Visual Studio Code &#x3D; TypeScript + Electron</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web">Web入门（MDN）</a></li>
<li><a href="https://nodejs.org/zh-cn/docs/es6/">Node.js简介</a></li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>检查<code>Node.js</code>以及包管理器<code>npm</code>是否正确安装</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">node -v<br>npm -v<br></code></pre></td></tr></table></figure>

<p>PS：若没有安装的话可以在官网根据文档介绍安装</p>
<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3><ul>
<li>直接通过<code>git clone https://github.com/electron/electron-quick-start</code></li>
<li>npm创建</li>
<li>手动创建</li>
</ul>
<h4 id="git创建"><a href="#git创建" class="headerlink" title="git创建"></a>git创建</h4><p>输入命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">git clone https://github.com/electron/electron-quick-start<br></code></pre></td></tr></table></figure>

<p>PS：也可以直接下载项目压缩包</p>
<p>得到文件<code>electron-quick-start</code></p>
<p>输入命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">cd electron-quick-start<br>npm install <br>npm start<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211101170519553.png" alt="image-20211101170519553" style="zoom:50%;" />

<h4 id="npm创建"><a href="#npm创建" class="headerlink" title="npm创建"></a>npm创建</h4><p>输入命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">npx create-electron-app@latest my-app<br>cd my-app<br>npm start<br></code></pre></td></tr></table></figure>

<p>执行上述命令后，会得到如下文件结构：</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/electron2.JPG" style="zoom:67%;" />

<p>运行结果：</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/electron.JPG" style="zoom:50%;" />

<p>打包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">npm run make<br></code></pre></td></tr></table></figure>

<h4 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h4><p>输入命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">mkdir my-electron-app  //创建文件夹<br>cd my-electron-app   //进入文件夹<br>npm init  //初始化命令<br></code></pre></td></tr></table></figure>

<p>将electron包安装到应用的开发依赖中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">npm install --save-dev electron<br></code></pre></td></tr></table></figure>

<p>在配置文件<code>packge.json</code>中添加启动命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;script&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;electron .&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>在根目录下创建</p>
<ul>
<li><p>空文件<code>main.js</code>（控制主进程）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-comment">// 控制应用生命周期和创建原生浏览器窗口的模组</span><br><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWindow</span> () &#123;<br>  <span class="hljs-comment">// 创建浏览器窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-attr">preload</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;preload.js&#x27;</span>)<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-comment">// 加载 index.html</span><br>  mainWindow.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><br>  <span class="hljs-comment">// 打开开发工具</span><br>  <span class="hljs-comment">// mainWindow.webContents.openDevTools()</span><br>&#125;<br><br><span class="hljs-comment">// 这段程序将会在 Electron 结束初始化</span><br><span class="hljs-comment">// 和创建浏览器窗口的时候调用</span><br><span class="hljs-comment">// 部分 API 在 ready 事件触发后才能使用。</span><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">createWindow</span>()<br><br>  app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 通常在 macOS 上，当点击 dock 中的应用程序图标时，如果没有其他</span><br>    <span class="hljs-comment">// 打开的窗口，那么程序会重新创建一个窗口。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">BrowserWindow</span>.<span class="hljs-title function_">getAllWindows</span>().<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">createWindow</span>()<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 除了 macOS 外，当所有窗口都被关闭的时候退出程序。 因此，通常对程序和它们在</span><br><span class="hljs-comment">// 任务栏上的图标来说，应当保持活跃状态，直到用户使用 Cmd + Q 退出。</span><br>app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;window-all-closed&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">platform</span> !== <span class="hljs-string">&#x27;darwin&#x27;</span>) app.<span class="hljs-title function_">quit</span>()<br>&#125;)<br><br><span class="hljs-comment">// 在这个文件中，你可以包含应用程序剩余的所有部分的代码，</span><br><span class="hljs-comment">// 也可以拆分成几个文件，然后用 require 导入。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>预加载脚本<code>preload.js</code></p>
<p>预加载脚本在渲染器进程进程加载之前加载，并有权访问两个渲染器全局（<code>window</code>和<code>document</code>）和Node.js环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//访问Node.js process.version 对象，并运行一个基本的 replaceText 辅助函数将版本号插入到HTML中</span><br><span class="hljs-comment">//所有的Node.js API 都可以在预加载过程中使用</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">replaceText</span> = (<span class="hljs-params">selector, text</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(selector)<br>    <span class="hljs-keyword">if</span> (element) element.<span class="hljs-property">innerText</span> = text<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dependency <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;chrome&#x27;</span>, <span class="hljs-string">&#x27;node&#x27;</span>, <span class="hljs-string">&#x27;electron&#x27;</span>]) &#123;<br>    <span class="hljs-title function_">replaceText</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;dependency&#125;</span>-version`</span>, process.<span class="hljs-property">versions</span>[dependency])<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>页面<code>index.html</code>（加载进窗口的内容）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--index.html--&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    We are using Node.js <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;node-version&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>,<br>    Chromium <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chrome-version&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>,<br>    and Electron <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;electron-version&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<br><br>    &lt;！-- 您也可以此进程中运行其他文件 --&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./renderer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>运行效果图：</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/image-20211101170519553.png" alt="image-20211101170519553" style="zoom:50%;" />

<h3 id="在渲染进程中调用Node接口-点击按钮写入文件"><a href="#在渲染进程中调用Node接口-点击按钮写入文件" class="headerlink" title="在渲染进程中调用Node接口(点击按钮写入文件)"></a>在渲染进程中调用Node接口(点击按钮写入文件)</h3><p>在主进程(main.js)<code>createWindow</code>中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">webPreferences</span>:&#123;<br>   <span class="hljs-comment">//浏览器的js可以支持node接口</span><br>   <span class="hljs-attr">nodeIntegration</span>:<span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">false</span>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>在页面中添加按钮并引用渲染进程</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add-file&quot;</span>&gt;</span>添加文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/render.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//render.js</span><br><span class="hljs-keyword">let</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    i++;<br>    fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">`input<span class="hljs-subst">$&#123;i&#125;</span>.txt`</span>,<span class="hljs-string">&#x27;点击按钮写入的内容&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(err)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入完毕&#x27;</span>);<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行后点击按钮会生成一个.txt文件：</p>
<img src="https://miedamie.oss-cn-beijing.aliyuncs.com/img/electron3.JPG" style="zoom:67%;" />



]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>UML---类图</title>
    <url>/2021/04/24/UML---%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="bulb-类图简介"><a href="#bulb-类图简介" class="headerlink" title=":bulb:类图简介"></a>:bulb:类图简介</h2><p>​		 类图（Class diagram）是显示了模型的静态结构，模型中存在的类、类的内部结构以及它们与其他类的关系等。（类图图示了所构建系统的所有实体、实体的内部结构以及实体之间的关系）</p>
<h2 id="bulb-类图结构"><a href="#bulb-类图结构" class="headerlink" title=":bulb:类图结构"></a>:bulb:类图结构</h2><p><img src="https://img-blog.csdnimg.cn/20210424151025861.JPG"><br><img src="https://img-blog.csdnimg.cn/20210424152520880.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d5YW5nYQ==,size_16,color_FFFFFF,t_70"><br><em>指定接口的方式：再类名上方添加<interface></em></p>
<h2 id="bulb-类图中的事物"><a href="#bulb-类图中的事物" class="headerlink" title=":bulb:类图中的事物"></a>:bulb:类图中的事物</h2><ul>
<li>接口：一组操作的集合，只有操作的声明而没有实现</li>
<li>抽象类：不能被实例化的类，一般至少包含一个抽象操作</li>
<li>模板类：一种参数化的类，在编译时把模板参数绑定到不同的数据类型，从而产生不同的类<br> <img src="https://img-blog.csdnimg.cn/20210424154652676.JPG"></li>
</ul>
<h2 id="bulb-类图中的关系及代码映射（java）"><a href="#bulb-类图中的关系及代码映射（java）" class="headerlink" title=":bulb:类图中的关系及代码映射（java）"></a>:bulb:类图中的关系及代码映射（java）</h2><ul>
<li><p>类的映射<br> <img src="https://img-blog.csdnimg.cn/20210424163708231.png"><br>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Start</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Stop</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">public</span> abstrct <span class="hljs-type">int</span> <span class="hljs-title function_">Run</span><span class="hljs-params">(<span class="hljs-type">float</span> fSpeed)</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> fMaxSpeed;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>关联关系（Association）：对象之间一种引用关系，由使用类指向被关联类（可以是单向和双向）<br> eg：客户类与订单类<br>  <img src="https://img-blog.csdnimg.cn/2021042416150334.png"></p>
</li>
</ul>
<p> 1.双向关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>  <span class="hljs-keyword">private</span> Order[] order;<br>  ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span>&#123;<br>   <span class="hljs-keyword">private</span> Customer customer;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>   2.单向关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>  <span class="hljs-keyword">private</span> Address address;<br>  ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>3.自关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>   <span class="hljs-keyword">private</span> Node subNode;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li><p>聚合关系（Aggregation）：一种不稳定的包含关系，较强于一般关联，整体和局部的关系，局部也可单独存在<br> eg:学校类与学生类<br> <img src="https://img-blog.csdnimg.cn/20210424171005963.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>  ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>&#123;<br>  <span class="hljs-keyword">private</span> List&lt;Student&gt; students;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>组合关系（Composition）：一种强烈的聚合关系，部分不能脱离整体存在<br>eg:窗口类和菜单类<br><img src="https://img-blog.csdnimg.cn/20210424171101192.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>  ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>&#123;<br>  <span class="hljs-keyword">private</span> List&lt;Menu&gt; menus;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>依赖关系（Dependency）：对象之间最弱的一种关联方式，临时性的关联。一般指由局部变量、函数参数、返回值建立的对其他对象的调用关系。（使用类指向被依赖类）<br><img src="https://img-blog.csdnimg.cn/2021042417121472.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Screwdriver</span> &#123;    <span class="hljs-comment">//螺丝刀，作为人类的工具，是用来被人类使用的</span><br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">screw</span><span class="hljs-params">(Screwdriver src)</span>&#123;    <span class="hljs-comment">//拧螺丝，需使用螺丝刀</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>依赖关系有如下三种情况：<br>     1、A类是B类中的（某中方法的）局部变量；<br>      2、A类是B类方法当中的一个参数；<br>     3、A类向B类发送消息，从而影响B类发生变化</p>
<ul>
<li>泛化关系（Generalization）：对象之间耦合度最大的一种关系，子类继承父类的所有细节。（箭头从子类指向父类）</li>
</ul>
<p> 要求：<br>     1、子类与父类应该完全一致，父类所具有的属性、操作，子类应该都有；<br>     2、子类中除了与父类一致的信息以外，还包括额外的信息；<br>     3、可以使用父类的实例的地方，也可以使用子类的实例；</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li>实现关系（Realization）：接口和实现类的关系（实现类指向接口）<br><img src="https://img-blog.csdnimg.cn/20210424170019420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d5YW5nYQ==,size_16,color_FFFFFF,t_70"><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vechicle</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>     ...<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>     ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="bulb-生动形象的实例"><a href="#bulb-生动形象的实例" class="headerlink" title=":bulb:生动形象的实例"></a>:bulb:生动形象的实例</h2><p><img src="https://img-blog.csdnimg.cn/20210424163039410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d5YW5nYQ==,size_16,color_FFFFFF,t_70"><br>:pushpin:图源：<a href="https://www.jianshu.com/p/57620b762160">https://www.jianshu.com/p/57620b762160</a><br>:pushpin:参考博客：<a href="https://www.cnblogs.com/chen-chen-chen/p/12295463.html">https://www.cnblogs.com/chen-chen-chen/p/12295463.html</a></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>类图</tag>
      </tags>
  </entry>
</search>
